{
  "name": "Nobel",
  "tagline": "Nobel (code-generator) creates a REST API for your Arduino board, based on a RAML definition.",
  "body": "nobel\r\n=====\r\n\r\n[![NPM version][npm-image]][npm-url]\r\n[![NPM Downloads][downloads-image]][downloads-url]\r\n<!--[![Build status][travis-image]][travis-url]\r\n[![Test coverage][coveralls-image]][coveralls-url]-->\r\n\r\nNobel (code-generator) creates a REST API for your [Arduino](http://arduino.cc/) board, based on a [SWAGGER](http://swagger.io/) or [RAML](http://raml.org) definition.\r\n\r\n## Description\r\n\r\nNobel scaffolds an Arduino application that exposes a REST API.\r\nThen, you can write the logic for interacting with your physical devices inside methods that will be executed when the corresponding URL is invoked.\r\n\r\n### Example\r\n\r\nConsidering the following Swagger code:\r\n\r\n```yaml\r\nswagger: \"2.0\"\r\ninfo:\r\n  version: \"0.0.1\"\r\n  title: NobelTestingAPI\r\npaths:\r\n  /servo:\r\n    post:\r\n      description: |\r\n        Moves the servo to the specified angle.\r\n      parameters:\r\n        - name: angle \r\n          in: body\r\n          description: angle object\r\n          required: true\r\n          schema:\r\n            $ref: '#/definitions/Angle'\r\n      responses:\r\n        200:\r\n          description: Successful response\r\n          schema:\r\n            $ref: '#/definitions/Angle'\r\n    put:\r\n      description: |\r\n        Moves the servo buy Adding the specified angle (could be negative)\r\n      parameters:\r\n        - name: angle \r\n          in: body\r\n          description: angle object\r\n          required: true\r\n          schema:\r\n            $ref: '#/definitions/Angle'\r\n      responses:\r\n        200:\r\n          description: Successful response\r\n          schema:\r\n            $ref: '#/definitions/Angle'\r\n    get:\r\n      description: |\r\n       Returns the current servo angle\r\n      responses:\r\n        200:\r\n          description: Successful response\r\n          schema:\r\n            $ref: '#/definitions/Angle'\r\ndefinitions:\r\n  Angle:\r\n    description: Task object\r\n    properties:\r\n      angle:\r\n        type: integer\r\n        description: task object name\r\n    required:\r\n      - angle\r\n```\r\n\r\n\r\nor the following RAML code\r\n\r\n```yaml\r\n#%RAML 0.8\r\ntitle: NobelTestingAPI\r\n/servo:\r\n  post:\r\n    description: |\r\n      Moves the servo to the specified angle.\r\n    body:\r\n      application/json:\r\n        example: |\r\n          {\"angle\": 71}\r\n  put:\r\n    description: |\r\n      Moves the servo buy Adding the specified angle (could be negative)\r\n    body:\r\n      application/json:\r\n        example: |\r\n          {\"angle\": -10}\r\n  get:\r\n    description: |\r\n      Returns the current servo angle\r\n    responses:\r\n      200:\r\n        body:\r\n          application/json:\r\n            example: |\r\n              { \"angle\": 71 }\r\n```\r\n\r\n\r\n\r\nNobel generates a project with several files (following the Arduino specs for splitting a program). One of the files contains the *Handlers*, where\r\nyou can write your own code. Associated to the RAML example:\r\n\r\n```c\r\n// Handlers\r\n\r\nvoid servoHandler(WebServer &server, WebServer::ConnectionType verb, String uriParams, String queryParams) {\r\n  switch (verb)\r\n    {\r\n\r\n    case WebServer::POST:\r\n        server.httpSuccess();\r\n        break;\r\n\r\n    case WebServer::PUT:\r\n        server.httpSuccess();\r\n        break;\r\n\r\n    case WebServer::GET:\r\n        server.httpSuccess();\r\n        break;\r\n\r\n    default:\r\n        server.httpFail();\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n## Installation\r\n\r\n### Pre-requisites\r\n- NodeJS\r\n- NPM\r\n- Arduino development environment (This is not needed to run Nobel, but will be needed to make something useful with it).\r\n\r\n\r\n### Install Nobel\r\nInstalling Nobel is really simple.\r\n- Open a terminal/command line\r\n- type `npm install -g nobel`\r\n\r\n... That's all you need.\r\n\r\n\r\n## Usage\r\n\r\nNobel is a Command Line Interface (CLI), which means that you will be executing it from a terminal/command line (I don't see a clear value on building a GUI for this).\r\n\r\n`nobel -s [your_swagger_or_raml_file] -n [your_project_name]`\r\n\r\nThe line above shows the minimum parameters set you need to specify in order to scaffold an Arduino Application using Nobel. The result is:\r\n```c\r\n.\r\n└── myArduinoRobot\r\n    ├── A_functions.ino\r\n    ├── B_definitions.ino\r\n    ├── C_handlers.ino\r\n    ├── D_initialization.ino\r\n    └── myArduinoRobot.ino\r\n```\r\n\r\nYou can find a description of each file in the following sections.\r\n\r\n### Arguments\r\n\r\n| Argument | Required | Description  |\r\n| ------------- | ------------- | ----- |\r\n| -s --source | YES | The Swagger or RAML file describing the API to implement on the Arduino program. |\r\n| -n --name   | YES | The name of your project. Nobel will create a folder with this name, and one main project file inside named like this. |\r\n| -t --target | NO | The target directory where the project will be placed. If not specified, the project will be created on the folder where you are running Nobel. |\r\n| -il --installLibraries | NO | If specified, it installs the required Arduino libraries on the folder you specify. [Click here to figure out where this folder is.](http://arduino.cc/en/Guide/Libraries) |\r\n| -h --help | NO | Really? Yes, the user manual will be printed in the terminal/command line |\r\n\r\n## Once your app is there\r\n- You just need to open the project with the Arduino IDE (you can use your preferred one, but all this project has been made using the [Official Arduino IDE](http://arduino.cc/en/Main/Software)).\r\n**Important**: If you are installing libraries, you will need to restart the Arduino IDE for those to be recognized (I can't do anything about it. Arduino IDE has some tricky parts. Get over it ;)).\r\n- Compile: If it's not working, something is wrong. Nobel is thought to scaffold a right-away working application (that won't do anything until you put your code on it). If anything goes wrong at anytime, [create an issue](nobel/issues/)\r\n- Put your own code!\r\n\r\n### Files\r\nCoding in Arduino is really a lot of fun (despite of/becouse of/but/your choice) it presents some challenges. The main one here: **Memory**.\r\nThere could be better ways of implementing the code Nobel creates, but I haven't found it yet (feel free of [making your own suggestions](nobel/issues/). That won't hurt my feelings at all).\r\nBecause of this, I needed to hardcode some values (yes, shame on me). You only need to worry about it if you need to **manually** add new resources. If not:\r\n- [your_project_name].ino: Main file. It only includes the libraries required by all of the other files. No need to touch at all.\r\n- A_functions.ino: Contains functions that will be used by the application to parse and route the URLs to the proper handlers (It is not that simple to put these into a library, thanks for asking).\r\n- B_definitions.ino: You will probably need to define some variables that you will use later in a global way. Even though you will probably initialize these\r\n  on `D_initialization.ino`, you will use these in `C_Handlers.ino`, and, since Arduino concatenates in alphabetical order (excepting for the main file),\r\n  not declaring the variables here, will result in errors.\r\n- C_Handlers.ino: You will write your logic here!!! A function will be generated per each result, and a SWITCH CASE inside of it, to determine the HTTP verb being invoked (this could be changing in the future, supporting other code styles. [For Example: One function per Resource-Verb combination](https://github.com/nohorbee/nobel/issues/4))\r\n- D_Initialization.ino: You need a place where everything starts. The `setup` and `loop` functions (which Arduino calls when *booting*) are placed here for you to complete as needed.\r\n\r\nSeeing the example is the best way of understanding how to code.\r\n*Note*: The scaffolded application [will use DHCP](https://github.com/nohorbee/nobel/issues/8). You can find the code to change this in the `D_Initialization.ino` file (`setup` function)\r\n\r\n### Manually Adding new resources\r\n***Sorry!*** I'll try to improve this, but this far, for an MVP, it is what it is!\r\n\r\n**Don't bother reading this if you are NOT manually adding new resources.**\r\n\r\n#### A_Functions.ino\r\n- Since `sizeof` function is not properly working, I needed to hardcode the resources array length on the very first lin:\r\n  `const byte SIZE_RESOURCES = 5; // constant until resolve what's going on with sizeof`. Change it if you manually add or remove resources.\r\n- Since I'm using a FLASH_ARRAY (basically for placing *big* amounts of data in the program memory instead of the variables space), I can't freely use an array and pass pointers as parameters or return these. So, the array needs to be defined inside the function that will use it. *ugh indeed*.\r\n```c\r\n FLASH_STRING_ARRAY(resources,\r\n      PSTR(\"/resourceA/\"),\r\n      PSTR(\"/resourceB/\"),\r\n      PSTR(\"/resourceC/\"),\r\n      PSTR(\"/resourceD/\"),\r\n      PSTR(\"/resourceE/\")\r\n      // add more if needed\r\n  );\r\n```\r\nWhen adding one, you will also need to add the proper *Handler* in D_Initialization.ino\r\n\r\n#### D_Initialization.ino\r\n\r\n- Add a new handler:\r\n```c\r\nvoid registerHandlers() {\r\nhandlers[0].method = &resourceAHandler;\r\nhandlers[1].method = &resourceBlHandler;\r\nhandlers[2].method = &resourceCHandler;\r\nhandlers[3].method = &resourceDHandler;\r\nhandlers[4].method = &resourceEHandler;\r\n}\r\n```\r\n**Important**: The order is the way of matching a resource with it handler!!! It's much more efficient and doable than trying to do some kind of \"reflection\". So, make sure of adding the handlers in the same order than the resources on the previous step.\r\nNow, a handler, is basically a pointer to a function (Nobel places these functions on `C_Handlers.ino`). So, if you have `&resourceAHandler`, you will need:\r\n\r\n#### C_Handlers.ino\r\n```c\r\nvoid resourceAHandler(WebServer &server, WebServer::ConnectionType verb, String uriParams, String queryParams) {\r\n  // Your code here (generally, start with a switch)\r\n}\r\n\r\n```\r\n\r\n\r\n## Hands On Example\r\n\r\n### Create the API definition file.\r\n\r\nYou can choose to define your API by using Swagger or RAML. It's up to you ;)\r\n\r\n#### Swagger\r\n\r\n```yaml\r\nswagger: \"2.0\"\r\ninfo:\r\n  version: \"0.0.1\"\r\n  title: NobelExampleAPI\r\npaths:\r\n  /led:\r\n    post:\r\n      description: |\r\n        Turns the light on\r\n      responses:\r\n        200:\r\n          description: Successful response\r\n    delete:\r\n      description: |\r\n        Turns the light off\r\n      responses:\r\n        200:\r\n          description: Successful response\r\n```\r\n\r\n#### RAML\r\n\r\n\r\n```yaml\r\n#%RAML 0.8\r\ntitle: NobelExampleAPI\r\n/led:\r\n  post:\r\n    description: Turns the light on\r\n  delete:\r\n    description: Turns the light off\r\n```\r\nand save it (the example asumes that it will be called `swaggerExample.yaml` or `ramlExample.raml`)\r\n\r\n### Scaffold the application  \r\n\r\nFor Swagger\r\n```\r\nnobel -s swaggerExample.yaml -n ledController\r\n```\r\nFor RAML\r\n```\r\nnobel -s ramlExample.raml -n ledController\r\n```\r\n#### or\r\nFor Swagger  \r\n```\r\nnobel -s nobelExample.raml -n ledController -il [path_to_your_arduino_libraries_directory]\r\n```\r\nFor RAML  \r\n```\r\nnobel -s nobelExample.raml -n ledController -il [path_to_your_arduino_libraries_directory]\r\n```\r\nif you haven't ever installed the required libraries.\r\n\r\n### Put your own code\r\n- Open the IDE.\r\n\r\n#### B_Definitions.ino\r\nAdd this line:\r\n```c\r\nbyte ledPin = 9; // It's a good practice to use a variable to semantically represent your Arduino output.\r\n```\r\n\r\n#### D_Initialization.ino\r\nAdd this line in the `void setup()` function\r\n```c\r\npinMode(ledPin, OUTPUT); // We are specifying that the pin 9 will be used as an output.\r\n```\r\n\r\nThe function code should look like this:\r\n```c\r\nvoid setup() {\r\n  Serial.begin(9600);\r\n  pinMode(ledPin, OUTPUT);\r\n  ethStart();\r\n  registerHandlers();\r\n  webserver.setFailureCommand(&dispatch);\r\n  webserver.begin();\r\n}\r\n```\r\n\r\n#### C_Handlers\r\n```c\r\ndigitalWrite(ledPin, HIGH); // Turns the led on\r\ndigitalWrite(ledPin, LOW); // Turns the led off\r\n```\r\n\r\nLet's add both calls to the `POST` and `DELETE` methods, and the final code should look like this:\r\n\r\n```c\r\nvoid ledHandler(WebServer &server, WebServer::ConnectionType verb, String uriParams, String queryParams) {\r\n  switch (verb)\r\n    {\r\n\r\n    case WebServer::POST:\r\n        digitalWrite(ledPin, HIGH);\r\n        server.httpSuccess();\r\n        break;\r\n\r\n    case WebServer::DELETE:\r\n        digitalWrite(ledPin, LOW);\r\n        server.httpSuccess();\r\n        break;\r\n\r\n    default:\r\n        server.httpFail();\r\n    }\r\n}\r\n```\r\n\r\n### Compile and deploy\r\n\r\nBy default, the generated code will make Arduino take an IP by using DHCP. Open a [*Serial Monitor*](http://arduino.cc/en/guide/Environment#serialmonitor) to see the assigned IP.\r\nIn order to test the app, use any program capable of sending HTTP messages via network. [Postman extension for chrome](https://chrome.google.com/webstore/detail/postman-rest-client/fdmmgilgnpjigdojojpjoooidkmcomcm?hl=en) is my favorite.\r\n- POST http://[the_ip_DHCP_assigned]/led   (should turn the led ON).\r\n- DELETE http://[the_ip_DHCP_assigned]/led   (should turn the led OFF).\r\n\r\n## Contributing to this code\r\n- If you are using Atom, please make sure that the following configuration is correct. If not, it will add or remove \"\\n\" and spaces characters from your templates making the unit tests to fail\r\n![alt text](images/atom-config.png)\r\n\r\n\r\n## Credits\r\n\r\n- Without any doubt, I would have quit the idea of creating this project if I didn't find a good HTTP server for Arduino.\r\nSo, it wouldn't be possible at all without [Webduino](https://github.com/sirleech/Webduino) by [sirleech](https://github.com/sirleech). Thanks to him and his amazing job.\r\n- 2 KB for all my variables? Where to put the *resources* array? In the Program Memory!!! That is possible thanks to the [Flash](https://github.com/mikalhart/Flash) module by [mikalhart](https://github.com/mikalhart).\r\n\r\n\r\n\r\n[npm-image]: https://img.shields.io/npm/v/nobel.svg?style=flat\r\n[npm-url]: https://npmjs.org/package/nobel\r\n[downloads-image]: https://img.shields.io/npm/dm/nobel.svg?style=flat\r\n[downloads-url]: https://npmjs.org/package/nobel\r\n[travis-image]: https://img.shields.io/travis/nohorbee/nobel.svg?style=flat\r\n[travis-url]: https://travis-ci.org/nohorbee/nobel\r\n[coveralls-image]: https://img.shields.io/coveralls/nohorbee/nobel.svg?style=flat\r\n[coveralls-url]: https://coveralls.io/r/nohorbee/nobel?branch=master\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}